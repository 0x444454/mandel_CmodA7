// mandel_CmodA7
// DDT's fixed-point Mandelbrot generator for Digilent CMod A7 FPGA board (XC7A35T).
// Should be easily portable to other boards.
//
// Check Github poge for more info:
//
//   https://github.com/0x444454/mandel_CmodA7
//
// Use Xilinx Vivado to build. I use Vivado v2025.2.
//
// LICENSE: Creative Commons, CC BY
//          https://creativecommons.org/licenses/by/4.0/deed.en
//
// Revision history [authors in square brackets]:
//   2026-01-30: First implementation, 100 MHz, 15 Mandel cores. Some timings warnings, but seems to work ok. [DDT]


// Resolution: 960x544 (DVI-style TMDS over HDMI connector)
//   Pixel clock: ~38.025 MHz
//   TMDS serdes: 5x pixel clock (~190.125 MHz)
//
// Controls (digital joystick, active-low with internal pullups):
//   - UP/DOWN/LEFT/RIGHT: pan (when SET not pressed)
//   - Hold SET (Action) + tap UP/DOWN: zoom in/out (2x)
//   - Hold SET (Action) + hold LEFT/RIGHT: dec/inc iterations (repeat)
//   - RST: reset zoom to default (scale only)
//
module top(
    input  logic clk12,

    input  logic joy_up_n,
    input  logic joy_down_n,
    input  logic joy_left_n,
    input  logic joy_right_n,
    input  logic joy_mid_n,
    input  logic joy_set_n,
    input  logic joy_rst_n,

    // On-board RGB LED (active-low on Cmod A7)
    output logic led0_r,
    output logic led0_g,
    output logic led0_b,

    // External async SRAM (Cmod A7)
    output logic [18:0] MemAdr,
    inout  wire  [7:0]  MemDB,
    output logic        RamOEn,
    output logic        RamWEn,
    output logic        RamCEn,

    // HDMI / TMDS
    output wire        tmds_clk_p,
    output wire        tmds_clk_n,
    output wire [2:0]  tmds_d_p,
    output wire [2:0]  tmds_d_n
);

    localparam int FB_W   = 960;
    localparam int FB_H   = 544;
    localparam int FB_AW  = $clog2(FB_W * FB_H); // 19 bits for 522,240 pixels

    // clk100 is generated by the MMCM (about 99.7377 MHz with the current clock plan).
    localparam int CLK100_HZ = 99_737_705;

    // -------------------------------------------------------------------------
    // Clocks (from 12 MHz):
    //   - clk100  : Mandel/scheduler (~99.74 MHz)
    //   - clk_pix : pixel clock (~38.025 MHz)
    //   - clk_5x  : TMDS serdes clock (~190.125 MHz)
    // -------------------------------------------------------------------------
    logic clk100;
    logic clk_pix;
    logic clk_5x;
    logic mmcm_locked;

    clk_gen_mmcm u_clkgen(
        .clk12(clk12),
        .rst(1'b0),
        .clk_pix(clk_pix),
        .clk100(clk100),
        .clk_5x(clk_5x),
        .locked(mmcm_locked)
    );

    // -------------------------------------------------------------------------
    // Power-on reset (held until MMCM locked, then for a short counter interval).
    // -------------------------------------------------------------------------
    logic [22:0] por_cnt;
    logic        por_done;
    always_ff @(posedge clk100 or negedge mmcm_locked) begin
        if (!mmcm_locked) begin
            por_cnt  <= 23'd0;
            por_done <= 1'b0;
        end else begin
            if (!por_done) begin
                por_cnt <= por_cnt + 23'd1;
                if (&por_cnt) por_done <= 1'b1;
            end
        end
    end

    logic rst_async;
    assign rst_async = (!mmcm_locked) || (!por_done);

    // Reset synchronizers for each clock domain (active-high reset).
    logic [1:0] rst100_sync;
    logic [1:0] rstpix_sync;
    logic [1:0] rst5x_sync;

    always_ff @(posedge clk100 or posedge rst_async) begin
        if (rst_async) rst100_sync <= 2'b11;
        else rst100_sync <= {rst100_sync[0], 1'b0};
    end

    always_ff @(posedge clk_pix or posedge rst_async) begin
        if (rst_async) rstpix_sync <= 2'b11;
        else rstpix_sync <= {rstpix_sync[0], 1'b0};
    end

    always_ff @(posedge clk_5x or posedge rst_async) begin
        if (rst_async) rst5x_sync <= 2'b11;
        else rst5x_sync <= {rst5x_sync[0], 1'b0};
    end

    logic rst;
    logic rst_pix;
    logic rst_5x;

    assign rst     = rst100_sync[1];
    assign rst_pix = rstpix_sync[1];
    assign rst_5x  = rst5x_sync[1];

    // -------------------------------------------------------------------------
    // Time counter (unused by pixel core; kept for compatibility/debug).
    // -------------------------------------------------------------------------
    logic [31:0] t;
    always_ff @(posedge clk100) begin
        if (rst) t <= 32'd0;
        else t <= t + 32'd1;
    end

    // -------------------------------------------------------------------------
    // Video timing for 960x544 with totals 1120 x 566.
    // -------------------------------------------------------------------------
    logic [10:0] h_count;
    logic [9:0] v_count;
    logic       visible;
    logic       hsync;
    logic       vsync;
    logic       line_start_pix;
    logic       frame_start_pix;

    video_timing u_vtim(
        .clk(clk_pix),
        .rst(rst_pix),
        .h_count(h_count),
        .v_count(v_count),
        .hsync(hsync),
        .vsync(vsync),
        .visible(visible),
        .line_start(line_start_pix),
        .frame_start(frame_start_pix)
    );

    // -------------------------------------------------------------------------
    // Joystick controls (debounced).
    // -------------------------------------------------------------------------
    logic move_up, move_down, move_left, move_right, move_tick;
    logic zoom_in_pulse, zoom_out_pulse, iters_dec_pulse, iters_inc_pulse;
    logic zoom_reset_pulse;

    logic bU, bD, bL, bR, bA, bM, bRST;

    joystick_buttons #(
        .CLK_HZ(CLK100_HZ),
        .SAMPLE_HZ(1000),
        .MOVE_HZ(512)      // 2x faster pan repeat
    ) u_joy(
        .clk(clk100),
        .rst(rst),

        .joy_up_n(joy_up_n),
        .joy_down_n(joy_down_n),
        .joy_left_n(joy_left_n),
        .joy_right_n(joy_right_n),
        .joy_set_n(joy_set_n),
        .joy_mid_n(joy_mid_n),
        .joy_rst_n(joy_rst_n),

        .up(bU),
        .down(bD),
        .left(bL),
        .right(bR),
        .action(bA),
        .mid(bM),
        .rst_zoom(bRST),

        .move_up(move_up),
        .move_down(move_down),
        .move_left(move_left),
        .move_right(move_right),
        .move_tick(move_tick),

        .zoom_in_pulse(zoom_in_pulse),
        .zoom_out_pulse(zoom_out_pulse),
        .iters_dec_pulse(iters_dec_pulse),
        .iters_inc_pulse(iters_inc_pulse),

        .zoom_reset_pulse(zoom_reset_pulse)
    );

    // -------------------------------------------------------------------------
    // Init center position, zoom, and iters.
    // -------------------------------------------------------------------------
    localparam int FRAC = 22;

    // Pixel step for initial view: 3.0 / FB_W in Q3.22
    localparam int signed SCALE_INIT_INT = (3 <<< FRAC) / FB_W;
    localparam logic signed [24:0] SCALE_INIT = $signed(SCALE_INIT_INT);

    logic signed [24:0] center_x_q;
    logic signed [24:0] center_y_q;
    logic signed [24:0] scale_q;
    logic [11:0]        max_iters;

    always_ff @(posedge clk100) begin
        if (rst) begin
            center_x_q <= -$signed(25'sd1 <<< (FRAC-1));   // -0.5 in Q3.22
            center_y_q <= 25'sd0;
            scale_q    <= SCALE_INIT;
            max_iters  <= 12'd128;
        end else begin
            // Pan: 1 pixel per move_tick.
            if (move_tick) begin
                if (move_left)  center_x_q <= center_x_q - $signed(scale_q);
                if (move_right) center_x_q <= center_x_q + $signed(scale_q);
                if (move_up)    center_y_q <= center_y_q - $signed(scale_q);
                if (move_down)  center_y_q <= center_y_q + $signed(scale_q);
            end

            // Zoom reset.
            if (zoom_reset_pulse) scale_q <= SCALE_INIT;

            // Zoom: tap.
            if (zoom_in_pulse) begin
                logic signed [24:0] s_next;
                s_next = $signed(scale_q) >>> 1;
                if (s_next == 25'sd0) s_next = 25'sd1; // min increment
                scale_q <= s_next;
            end
            if (zoom_out_pulse) scale_q <= $signed(scale_q) <<< 1;

            // Iters: repeat while holding Action. Clamp to [1..4095].
            if (iters_dec_pulse) begin
                if (max_iters <= 12'd16) max_iters <= 12'd1;
                else max_iters <= max_iters - 12'd16;
            end
            if (iters_inc_pulse) begin
                if (max_iters >= (12'd4095-12'd16)) max_iters <= 12'd4095;
                else max_iters <= max_iters + 12'd16;
            end
        end
    end

    // Trigger a full re-render on zoom/iters changes.
    logic render_restart;
    assign render_restart = zoom_in_pulse | zoom_out_pulse | iters_inc_pulse | iters_dec_pulse | zoom_reset_pulse;

    // -------------------------------------------------------------------------
    // Framebuffer writer (15 Mandel cores, out-of-order retirement).
    // Produces iter8 pixels into a 2-line BRAM write buffer.
    // The SRAM DMA commits full lines (no per-pixel SRAM writes).
    // -------------------------------------------------------------------------
    logic        wb_we;
    logic        wb_bank;
    logic [9:0]  wb_addr;
    logic [7:0]  wb_data;

    logic        wb_full0;
    logic        wb_full1;
    logic [9:0]  wb_y0;
    logic [9:0]  wb_y1;

    logic        commit_take;
    logic        commit_done;
    logic        commit_bank;

    logic        render_busy;

    logic [$clog2(FB_H)-1:0]  cur_y;

    fb_scanline_writer #(.FB_W(FB_W), .FB_H(FB_H)) u_writer(
        .clk(clk100),
        .rst(rst),

        .wb_we(wb_we),
        .wb_bank(wb_bank),
        .wb_addr(wb_addr),
        .wb_data(wb_data),

        .wb_full0(wb_full0),
        .wb_full1(wb_full1),
        .wb_y0(wb_y0),
        .wb_y1(wb_y1),

        .commit_take(commit_take),
        .commit_done(commit_done),
        .commit_bank(commit_bank),

        .t(t),

        .center_x_q(center_x_q),
        .center_y_q(center_y_q),
        .scale_q(scale_q),

        .restart(render_restart),
        .iters_q(max_iters),

        .cur_y(cur_y),
        .render_busy(render_busy)
    );

    // Track when the DMA is actively committing a render line to SRAM.
    logic commit_active;
    always_ff @(posedge clk100) begin
        if (rst) begin
            commit_active <= 1'b0;
        end else begin
            if (commit_take) commit_active <= 1'b1;
            if (commit_done) commit_active <= 1'b0; // wins if both asserted
        end
    end

    // RGB LED: red while rendering/committing, green when fully idle.
    // Cmod A7 RGB LED is active-low.
    logic calc_busy;
    assign calc_busy = render_busy | commit_active;

    always_comb begin
        if (calc_busy) begin
            led0_r = 1'b0;
            led0_g = 1'b1;
            led0_b = 1'b1;
        end else begin
            led0_r = 1'b1;
            led0_g = 1'b0;
            led0_b = 1'b1;
        end
    end

    // -------------------------------------------------------------------------
    // Cross domain sync: line/frame start pulses from clk_pix -> clk100.
    // clk100 is faster than clk_pix, so sampling a 1-cycle clk_pix pulse is safe.
    // -------------------------------------------------------------------------
    logic [2:0] line_sync;
    logic [2:0] frame_sync;

    always_ff @(posedge clk100) begin
        if (rst) begin
            line_sync  <= 3'b000;
            frame_sync <= 3'b000;
        end else begin
            line_sync  <= {line_sync[1:0], line_start_pix};
            frame_sync <= {frame_sync[1:0], frame_start_pix};
        end
    end

    logic line_pulse_100;
    logic frame_pulse_100;
    assign line_pulse_100  = line_sync[1] & ~line_sync[2];
    assign frame_pulse_100 = frame_sync[1] & ~frame_sync[2];

    logic        lb_we;
    logic        lb_bank_wr;
    logic [9:0]  lb_addr_wr;
    logic [7:0]  lb_data_wr;

    // -------------------------------------------------------------------------
    // 2-line BRAM render write buffer.
    // Port A: writer writes pixels (random x) for up to two render lines.
    // Port B: SRAM DMA reads sequential bytes when committing a full line.
    // -------------------------------------------------------------------------
    logic        rb_bank_rd;
    logic [9:0]  rb_addr_rd;
    logic [7:0]  rb_data_rd;

    linebuf_iter8 u_renderbuf(
        .clk_wr(clk100),
        .we(wb_we),
        .bank_wr(wb_bank),
        .addr_wr(wb_addr),
        .data_wr(wb_data),

        .clk_rd(clk100),
        .bank_rd(rb_bank_rd),
        .addr_rd(rb_addr_rd),
        .data_rd(rb_data_rd)
    );

    // -------------------------------------------------------------------------
    // SRAM line DMA:
    //   1) Prefetch next display line from SRAM -> BRAM linebuf (burst read)
    //   2) After prefetch, commit one full render line (if available) from
    //      renderbuf -> SRAM (burst write)
    // No per-pixel SRAM writes; no read/write interleaving.
    // -------------------------------------------------------------------------
    sram_line_dma #(
        .FB_W(FB_W),
        .FB_H(FB_H),
        .V_VISIBLE(544),
        .V_TOTAL(566)
    ) u_dma(
        .clk(clk100),
        .rst(rst),
        .line_pulse(line_pulse_100),
        .frame_pulse(frame_pulse_100),

        .MemAdr(MemAdr),
        .MemDB(MemDB),
        .RamOEn(RamOEn),
        .RamWEn(RamWEn),
        .RamCEn(RamCEn),

        .lb_we(lb_we),
        .lb_bank(lb_bank_wr),
        .lb_addr(lb_addr_wr),
        .lb_data(lb_data_wr),

        .rb_bank(rb_bank_rd),
        .rb_addr(rb_addr_rd),
        .rb_data(rb_data_rd),

        .wb_full0(wb_full0),
        .wb_full1(wb_full1),
        .wb_y0(wb_y0),
        .wb_y1(wb_y1),
        .commit_take(commit_take),
        .commit_done(commit_done),
        .commit_bank(commit_bank)
    );

    // -------------------------------------------------------------------------
    // BRAM line buffer (2 banks) and palette ROM.
    // Video scanout reads only BRAM at pixel clock.
    // -------------------------------------------------------------------------
    logic [9:0] lb_addr_rd;
    logic       lb_bank_rd;
    logic [7:0] iter8_d1;

    assign lb_addr_rd = visible ? h_count[9:0] : 10'd0;
    // Ping-pong the scanout line buffer by v_count LSB. The DMA uses the same policy
    // when writing prefetched lines (lb_bank=pref_line[0]).
    assign lb_bank_rd = v_count[0];

    linebuf_iter8 u_linebuf(
        .clk_wr(clk100),
        .we(lb_we),
        .bank_wr(lb_bank_wr),
        .addr_wr(lb_addr_wr),
        .data_wr(lb_data_wr),

        .clk_rd(clk_pix),
        .bank_rd(lb_bank_rd),
        .addr_rd(lb_addr_rd),
        .data_rd(iter8_d1)
    );

    // Palette cycling: while MID (bM) is held, advance a 0..254 rotation once per frame.
    // 'pal_rot' is a rotation offset: color[0] stays black, and colors [1..255] rotate as a 255-entry ring using modulo-255 arithmetic.
    // Color[0] (black) is not rotated; colors [1..255] are rotated as a 255-entry ring.
    logic       mid_pix_ff1;
    logic       mid_pix;
    logic [7:0] pal_rot;

    always_ff @(posedge clk_pix) begin
        if (rst_pix) begin
            mid_pix_ff1 <= 1'b0;
            mid_pix     <= 1'b0;
            pal_rot     <= 8'd0;
        end else begin
            mid_pix_ff1 <= bM;
            mid_pix     <= mid_pix_ff1;

            if (frame_start_pix && mid_pix) begin
                if (pal_rot == 8'd254) pal_rot <= 8'd0;
                else pal_rot <= pal_rot + 8'd1;
            end
        end
    end

    logic [7:0] iter8_pal;

    // Palette rotation is implemented as an index remap:
    //   - iter8==0 stays 0 (black)
    //   - iter8 in [1..255] is treated as a 255-entry ring, rotated by pal_rot.
    logic [7:0] iter8_minus1;
    logic [8:0] pal_sum;

    always_comb begin
        if (iter8_d1 == 8'd0) begin
            iter8_minus1 = 8'd0;
            pal_sum      = 9'd0;
            iter8_pal    = 8'd0;
        end else begin
            iter8_minus1 = iter8_d1 - 8'd1;
            pal_sum      = {1'b0, iter8_minus1} + {1'b0, pal_rot};
            // Rotate within [1..255] by doing mod-255 arithmetic on (iter8-1).
            if (pal_sum >= 9'd255) pal_sum = pal_sum - 9'd255;
            iter8_pal    = pal_sum[7:0] + 8'd1;
        end
    end

    logic [23:0] rgb888_d2;
    palette_rom_256x12 u_pal(
        .clk(clk_pix),
        .addr(iter8_pal),
        .rgb888(rgb888_d2)
    );

    // Align control signals with the 2-cycle pipeline (linebuf:1, palette:1).
    logic [1:0] de_pipe;
    logic [1:0] hsync_pipe;
    logic [1:0] vsync_pipe;

    always_ff @(posedge clk_pix) begin
        if (rst_pix) begin
            de_pipe    <= 2'b00;
            hsync_pipe <= 2'b00;
            vsync_pipe <= 2'b00;
        end else begin
            de_pipe    <= {de_pipe[0], visible};
            hsync_pipe <= {hsync_pipe[0], hsync};
            vsync_pipe <= {vsync_pipe[0], vsync};
        end
    end

    logic de_d2;
    logic hsync_d2;
    logic vsync_d2;
    assign de_d2    = de_pipe[1];
    assign hsync_d2 = hsync_pipe[1];
    assign vsync_d2 = vsync_pipe[1];

    // Palette output is RGB888.
    logic [7:0] r8;
    logic [7:0] g8;
    logic [7:0] b8;

    always_comb begin
        if (de_d2) begin
            r8 = rgb888_d2[23:16];
            g8 = rgb888_d2[15:8];
            b8 = rgb888_d2[7:0];
        end else begin
            r8 = 8'd0;
            g8 = 8'd0;
            b8 = 8'd0;
        end
    end

    // -------------------------------------------------------------------------
    // HDMI (DVI-style TMDS) output.
    // -------------------------------------------------------------------------
    hdmi_out u_hdmi(
        .clk_pix(clk_pix),
        .clk_5x(clk_5x),
        .rst_pix(rst_pix),
        .rst_ser(rst_5x),

        .red(r8),
        .green(g8),
        .blue(b8),
        .hsync(hsync_d2),
        .vsync(vsync_d2),
        .de(de_d2),

        .tmds_clk_p(tmds_clk_p),
        .tmds_clk_n(tmds_clk_n),
        .tmds_d_p(tmds_d_p),
        .tmds_d_n(tmds_d_n)
    );

endmodule
